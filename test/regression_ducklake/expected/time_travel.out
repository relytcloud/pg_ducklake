-- Test time-travel queries for DuckLake tables using GUC + UDF approach
-- Test 1: Basic time-travel with ducklake.as_of_timestamp GUC
CREATE TABLE tt_basic (id INT, value INT) USING ducklake;
INSERT INTO tt_basic VALUES (1, 100), (2, 200);
SELECT pg_sleep(0.2);
 pg_sleep 
----------
 
(1 row)

\! sleep 0.2
-- Store timestamp for time-travel
CREATE TEMP TABLE ts_storage (ts1 TEXT, ts2 TEXT);
INSERT INTO ts_storage SELECT to_char(now(), 'YYYY-MM-DD HH24:MI:SS.US'), NULL;
UPDATE tt_basic SET value = value + 1000;
-- Set GUC and query (should show original values)
DO $$ BEGIN PERFORM set_config('ducklake.as_of_timestamp', (SELECT ts1 FROM ts_storage), false); END $$;
SELECT * FROM tt_basic ORDER BY id;
 id | value 
----+-------
  1 |   100
  2 |   200
(2 rows)

-- Reset GUC and query current (should show updated values)
RESET ducklake.as_of_timestamp;
SELECT * FROM tt_basic ORDER BY id;
 id | value 
----+-------
  1 |  1100
  2 |  1200
(2 rows)

DROP TABLE tt_basic;
-- Test 2: Per-table snapshot with set_table_snapshot()
CREATE TABLE tt_sales (id INT, amount INT) USING ducklake;
INSERT INTO tt_sales VALUES (1, 100), (2, 200), (3, 300);
SELECT pg_sleep(0.2);
 pg_sleep 
----------
 
(1 row)

\! sleep 0.2
UPDATE ts_storage SET ts1 = to_char(now(), 'YYYY-MM-DD HH24:MI:SS.US');
INSERT INTO tt_sales VALUES (4, 400), (5, 500);
-- Set per-table snapshot and query
SELECT ducklake.set_table_snapshot('tt_sales', (SELECT ts1 FROM ts_storage));
 set_table_snapshot 
--------------------
 
(1 row)

SELECT COUNT(*), SUM(amount) FROM tt_sales;
 count | sum 
-------+-----
     3 | 600
(1 row)

-- Clear and query current
SELECT ducklake.clear_table_snapshots();
 clear_table_snapshots 
-----------------------
 
(1 row)

SELECT COUNT(*), SUM(amount) FROM tt_sales;
 count | sum  
-------+------
     5 | 1500
(1 row)

DROP TABLE tt_sales;
-- Test 3: Per-table snapshot takes priority over GUC
CREATE TABLE tt_priority (id INT, value TEXT) USING ducklake;
INSERT INTO tt_priority VALUES (1, 'v1');
SELECT pg_sleep(0.2);
 pg_sleep 
----------
 
(1 row)

\! sleep 0.2
UPDATE ts_storage SET ts1 = to_char(now(), 'YYYY-MM-DD HH24:MI:SS.US');
UPDATE tt_priority SET value = 'v2';
SELECT pg_sleep(0.2);
 pg_sleep 
----------
 
(1 row)

\! sleep 0.2
-- Store second timestamp
UPDATE ts_storage SET ts2 = to_char(now(), 'YYYY-MM-DD HH24:MI:SS.US');
UPDATE tt_priority SET value = 'v3';
-- Set GUC to ts2 (should show v2), but per-table to ts1 (should show v1)
DO $$ BEGIN PERFORM set_config('ducklake.as_of_timestamp', (SELECT ts2 FROM ts_storage), false); END $$;
SELECT ducklake.set_table_snapshot('tt_priority', (SELECT ts1 FROM ts_storage));
 set_table_snapshot 
--------------------
 
(1 row)

SELECT * FROM tt_priority ORDER BY id;
 id | value 
----+-------
  1 | v1
(1 row)

-- Clear per-table, GUC still active (should show v2)
SELECT ducklake.clear_table_snapshots();
 clear_table_snapshots 
-----------------------
 
(1 row)

SELECT * FROM tt_priority ORDER BY id;
 id | value 
----+-------
  1 | v2
(1 row)

-- Reset GUC (should show v3)
RESET ducklake.as_of_timestamp;
SELECT * FROM tt_priority ORDER BY id;
 id | value 
----+-------
  1 | v3
(1 row)

DROP TABLE tt_priority;
-- Test 4: JOIN with global GUC
CREATE TABLE tt_orders (order_id INT, amount INT) USING ducklake;
CREATE TABLE tt_customers (customer_id INT, name TEXT) USING ducklake;
INSERT INTO tt_orders VALUES (1, 100), (2, 200);
INSERT INTO tt_customers VALUES (1, 'Alice'), (2, 'Bob');
SELECT pg_sleep(0.2);
 pg_sleep 
----------
 
(1 row)

\! sleep 0.2
UPDATE ts_storage SET ts1 = to_char(now(), 'YYYY-MM-DD HH24:MI:SS.US');
UPDATE tt_orders SET amount = amount * 2;
UPDATE tt_customers SET name = 'Charlie' WHERE customer_id = 1;
-- Query both tables at historical timestamp via GUC
DO $$ BEGIN PERFORM set_config('ducklake.as_of_timestamp', (SELECT ts1 FROM ts_storage), false); END $$;
SELECT o.order_id, o.amount, c.name
FROM tt_orders o
JOIN tt_customers c ON o.order_id = c.customer_id
ORDER BY o.order_id;
 order_id | amount | name  
----------+--------+-------
        1 |    100 | Alice
        2 |    200 | Bob
(2 rows)

-- Current state
RESET ducklake.as_of_timestamp;
SELECT o.order_id, o.amount, c.name
FROM tt_orders o
JOIN tt_customers c ON o.order_id = c.customer_id
ORDER BY o.order_id;
 order_id | amount |  name   
----------+--------+---------
        1 |    200 | Charlie
        2 |    400 | Bob
(2 rows)

DROP TABLE tt_orders;
DROP TABLE tt_customers;
-- Test 5: Non-DuckLake table with GUC (should be ignored with NOTICE)
CREATE TABLE tt_heap (id INT);
INSERT INTO tt_heap VALUES (1);
SET ducklake.as_of_timestamp = '2025-01-01';
SELECT * FROM tt_heap;
NOTICE:  ducklake.as_of_timestamp is set but 'tt_heap' is not a DuckLake table, ignoring
NOTICE:  ducklake.as_of_timestamp is set but 'tt_heap' is not a DuckLake table, ignoring
 id 
----
  1
(1 row)

RESET ducklake.as_of_timestamp;
DROP TABLE tt_heap;
-- Test 6: set_table_snapshot on non-DuckLake table (should error)
CREATE TABLE tt_not_ducklake (id INT);
SELECT ducklake.set_table_snapshot('tt_not_ducklake', '2025-01-01');
ERROR:  table 'tt_not_ducklake' is not a DuckLake table
DROP TABLE tt_not_ducklake;
-- Test 7: Invalid timestamp format in set_table_snapshot (should error)
CREATE TABLE tt_invalid (id INT) USING ducklake;
INSERT INTO tt_invalid VALUES (1);
SELECT ducklake.set_table_snapshot('tt_invalid', 'invalid-timestamp');
ERROR:  invalid timestamp format: 'invalid-timestamp'
DROP TABLE tt_invalid;
-- Test 8: Aggregation with GUC time-travel
CREATE TABLE tt_agg (id INT, amount INT) USING ducklake;
INSERT INTO tt_agg VALUES (1, 10), (2, 20), (3, 30);
SELECT pg_sleep(0.2);
 pg_sleep 
----------
 
(1 row)

\! sleep 0.2
UPDATE ts_storage SET ts1 = to_char(now(), 'YYYY-MM-DD HH24:MI:SS.US');
INSERT INTO tt_agg VALUES (4, 40), (5, 50);
DO $$ BEGIN PERFORM set_config('ducklake.as_of_timestamp', (SELECT ts1 FROM ts_storage), false); END $$;
SELECT COUNT(*), SUM(amount), AVG(amount) FROM tt_agg;
 count | sum | avg 
-------+-----+-----
     3 |  60 |  20
(1 row)

RESET ducklake.as_of_timestamp;
SELECT COUNT(*), SUM(amount), AVG(amount) FROM tt_agg;
 count | sum | avg 
-------+-----+-----
     5 | 150 |  30
(1 row)

DROP TABLE tt_agg;
-- Cleanup
DROP TABLE ts_storage;
